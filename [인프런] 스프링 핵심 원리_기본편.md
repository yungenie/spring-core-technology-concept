# 🌱 스프링 핵심 원리 기본편
출저 : [`인프런 김영한 - 스프링 핵심 원리 기본편 강의`](https://inf.run/h6Gf)

<br>

## 목차
- [객체 지향 설계와 스프링](#객체-지향-설계와-스프링)
- [객체 지향 원리 적용](#객체-지향-원리-적용)
- [스프링 컨테이너와 스프링 빈](#스프링-컨테이너와-스프링-빈)
- [싱글톤 컨테이너](#싱글톤-컨테이너)
- [컴포넌트 스캔](#컴포넌트-스캔)
- [의존관계 자동 주입](#의존관계-자동-주입)
- [빈 생명주기 콜백](#빈-생명주기-콜백)
- [빈 스코프](#빈-스코프)

<br>

## 객체 지향 설계와 스프링
### 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생
- EJB > Road Johnson 오픈소스 공개 (EJG 한계 지적) > Juergen Hoeller, Yann Caroff가 Road Johnson 오픈 소스 제안 > 스프링 탄생 (겨울을 넘어 새로운 시작이라는 뜻)

### 스프링이란?
- `좋은 객체 지향` 애플리케이션을 개발할 수 있게 도와주는 프레임워크 입니다.

### 좋은 객체 지향 프로그래밍이란?
- 객체 지향 특징 : 추상화, 상속, 캡슐화, 다형성
- **역할과 구현을 안정적으로 분리**하여 `다형성`을 극대화 시켜 **유연하고 변경에 유리**하게 만든 것이 좋은 객체 지향 프로그래밍 입니다.

- 추상화 : 공통의 특징을 하나의 개념으로 다루는 것
- 캡슐화 : 객체의 필드와 메소드를 하나로 묶고,외부에서 쉽게 접근하지 못하도록 은닉하는 게 핵심입니다. (대표적으로 getter/setter 가 있습니다. )
- 다형성 : 하나의 타입을 여러 객체에 대입 가능합니다. ( 상위 클래스나 인터페이스 타입 변환을 허용합니다)
- 상속 : 상위 객체의 필드, 메소드를 하위 객체에서 사용하거나, 재정의 할 수 있습니다.

### 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
- SOLID - SRP, OCP, LSP, ISP, DIP    
- SRP : `단일 책임 원칙` (Single Responsibility Principle) 
  - **클래스에는 역할과 책임에 따라 분리** 해야 합니다. 그러므로 **한 클래스에는 하나의 역할**을 가져야 합니다.
  - ex) 구현 객체를 생성하고 연결하는 역할 담당. 객체를 기능에 맞게 실행하는 역할 담당 (관심사 분리)

- OCP : `개방-폐쇄 원칙` (Open/Closed Principle)  
  - **역할에 대해 변경은 닫혀** 있으나, **구현 기능에 대해서는 확장성이 열려** 있어야 합니다. (구성과 사용 역할의 분리)
  - **문제점** : 다형성을 사용했지만 구현 객체를 변경하려면 클라이언트 코드를 변경해야 합니다. (※ 클라이언트 : service)
  - **해결** : 객체를 생성하고 연관관계를 맺어주는 별도의 설정자가 필요합니다. (스프링 DI 컨테이너)
  
- LSP : `리스코프 치환 원칙` (Liskov Substitution Principle)
  - **하위 타입의 인스턴스가 상위 인스턴스로 대체**될 수 있어야 합니다.
  - 상위 인스턴스에서 추상화한 기능을 토대로 하위 타입 인스턴스는 목적에 맞는 기능을 구현해야 합니다.
  - ex) 자동차 전진을 하는 메서드인데 후진을 하는 메서드를 구현했을 경우

- ISP : `인터페이스 분리 원칙` (Interface Segregation Principle)
  - **특정 클라이언트에 맞게 인터페이스를 분리** 합니다. 

- DIP : `의존관계 역전 원칙` (Dependency Inversion Principle)
  - 클라이언트가 **인터페이스(추상화)에 의존**해야 **유연하게 구현체를 변경** 할 수 있습니다. 
  - **문제점** : 인터페이스에 의존하지만, 구현 클래스도 동시에 의존합니다. 
  - **해결** : 애플리케이션 전체 구성 담당을 생성해서 객체 인스턴스의 참조값(주소)를 의존관계 주입
 
- 정리 : 객체 지향의 🌺인 다형성만으로 구현 객체를 변경할 때 클라이언트 코드도 함께 변경됩니다. 다형성만으로는 OCP, DIP 위반 됩니다.
         따라서, 외부에서 구현 객체를 생성해서 의존관계를 주입해야합니다. (제어의 역전)

### 객체 지향 설계와 스프링
- 객체 지향 설계의 5가지 원칙의 위반되는 한계를 **스프링이 OCP, DIP까지 가능하게 지원**해줍니다.
<br>

## 객체 지향 원리 적용
### IoC 제어의 역전 (Inversion of Control)
- 개념 : 직접적인 호출이 아니라 프레임워크가 대신 호출한다는 의미로 `외부에서 관리`하는 것을 뜻합니다.
- ex) 외부에서 제어 흐름에 대한 권한 담당을 맡아 인터페이스의 구현 객체를 생성하고 실행을하고, 구현 객체는 실제 비지니스 로직 실행만 담당을 하게끔 합니다.

### 프레임워크 vs 라이브러리
- 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크 입니다.
- 내가 작성한 코드라 직접 제어의 흐름에 담당한다면 라이브러리 입니다.

### DI 의존관계 주입 (Dependency Injection)
- `클라이언트와 서버의 실제 의존관계가 연결`되는 것을 의존관계 주입이라고 합니다.
- **객체 인스턴스를 생성** 후 해당 **참조값을 전달**해서 연결시켜주는 것 입니다.
- 의존관계는 정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계로 분리해서 생각할 수 있습니다.

#### 정적인 클래스 의존관계
- 코드로만 보고 의존관계를 쉽게 판단할 수 있습니다. 
- 애플리케이션을 실행하지 않아도 분석 가능합니다.

#### 동적인 객체 인스턴스 의존관계
- **애플리케이션 실행 시점**에 생성된 객체 인스턴스의 참조값이 연결된 의존관계를 뜻합니다.

#### 의존관계 정리
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 유연하게 변경할 수 있습니다.

### DI 컨테이너
- `객체를 생성하고 관리하면서 의존관계를 연결`해주는 것을 IoC 컨테이너 or DI 컨테이너라고 합니다.
- 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 합니다.

### 3줄 요약 정리
> 1. 추상화(인터페이스)과 구현을 나눠서 각 **역할**을 나누고 구현 객체에 의존하지 않고 **추상에 의존**하게 하여 구성합니다. (SOLID)
> 2. 어플리케이션 실행시점에 추상화를 등록하고 비지니스 로직인 구현 객체의 인스턴스의 참조값으로 **생성자 의존관계 주입** 합니다. (IoC, DI)
> 3. **프레임워크(스프링)를 통해** 추상화를 등록하고 구현 객체 의존관계 주입을 **외부에서 관리**하게 하도록 합니다. (DI 컨테이너)
<br>

## 스프링 컨테이너와 스프링 빈
### 스프링 컨테이너 생성
- `ApplicationContext`를 스프링 컨테이너라 합니다.
- 구성정보를 통해서 스프링 컨테이너의 `스프링 저장소(빈이름, 빈객체)`에 생성합니다.
  - 구성정보는 AppConfig, 빈이름은 @Bean 어노테이션이 붙은 메서드명, 빈객체는 구현체 인스턴스 주소 입니다.
- 구성정보(설정정보)를 참고해서 **스프링 빈을 등록하는 동시에 의존관계를 주입**합니다.

### 스프링 빈 조회
- 거의 사용하진 않지만, 순수한 자바 애플리케이션에서 스프링 컨테이너를 생성해서 써야하는 경우가 있습니다.
- 그때 자동의존관계에서 문제 없이 해결할 수 있도록 ApplicationContext에서 bean을 조회해서 확인합니다.

### BeanFactory와 ApplicationContext
- BeanFactory, ApplicationContext 모두 스프링 컨테이너라고 합니다.
- BeanFactory(i/f) > ApplicationContext(i/f) > AnnotationConfig/ApplicationContext
  <img width="100%" alt="image" src="https://github.com/yungenie/spring-core-technology-concept/assets/28051638/ccd270d3-7564-4a4b-bb5c-63d1ec9c0d27">

#### BeanFactory
- `org.springframework:spring-beans` 패키지 안에 존재한다.
    - spring-beans 패키지는  Java Bean을 조작하기 위한 인터페이스와 클래스가 포함되어 있다.
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 **빈을 관리하고 조회**(검색)하는 역할을 담당
- getBean()을 제공한다.

#### ApplicationContext
- `org.springframework:spring-context` 패키지 안에 존재합니다.
  - spring-context 패키지는 메시지 소스, 옵저버 디자인패턴, 리소스 접근 등 기능을 추가하기 위해 bean 패키지를 기반으로 한다.
- BeanFactory를 상속받은 ListableBeanFactory의 하위 인터페이스 (BeanFactory의 하위 클래스)
- BeanFactory 기능을 모두 상속받아 제공한다.
- 빈을 관리하고 조회하는 기능은 물론 편리한 **부가 기능**을 제공합니다.
- MessageSource : 메시지 소스를 활용한 국제화 기능 (ex, 한국에서 들어오면 한국어로 영국에서 들어오면 영국어로 출력)
- EnvironmentCapable : 환경변수 처리 (로컬, 개발, 운영 등을 구분해서 처리)
- ApplicationEventPublisher : 애플리케이션 이벤트 (이벤트를 발행하고 구독하는 모델을 편리하게 지원)
  - 서비스간의 결합도를 낮추는 경우로 서브 로직이 에러나더라도 메인 로직은 정상적으로 완료 (ex, 회원가입 웰컴쿠폰)
- ResourceLoader : 편리한 리소스 조회 (파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회)

#### BeanFactory와 ApplicationContext 차이점
- 가장 큰 차이점은 빈의 로딩시점이 다릅니다.
- BeanFactory 컨테이너는 구동될 때 Bean 객체를 생성하는 게 아니라 객체를 실제로 사용하는 시점 즉, 클라이언트의 요청을 받는 시점(getBean())에 인스턴스화 되고 로드 됩니다. **(Lazy-Loading 지연로딩)**
- ApplicationContext 컨테이너 구동되는 시점에 Bean 객체들을 스캔하여 인스턴스화 시키고 인스턴스화된 Bean을 즉시 호출한다. **(Pre-Loading)**
- BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다. 


### 3줄 요약 정리
> 1. 스프링 컨테이너의 스프링 저장소(빈이름, 빈객체)에 스프링 빈을 등록하는 동시에 의존관계를 주입합니다.
> 2. 스프링 컨테이너의 스프링을 등록하는 방법은 크게 2가지가 있습니다.
>    - 직접 스프링 빈을 스프링 컨테이너에 등록하는 방법 (xml) (레거시 방법)
>    - 외부에서 메서드 호출해서 제공하는 방식으로 factoryBean을 통해 등록하는 방법 (AppConfig) (factoryBean method 방법)
> 3. 스프링이 **다양한 형태**의 설정 정보를 BeanDefinition으로 추상화해서 사용합니다.
<br>

## 싱글톤 컨테이너

### 싱글톤 패턴


```java
public class SingletonService {

    // 1. static 영역에 객체를 딱 1개만 생성해둔다.
    private static final SingletonService instance = new SingletonService();

    // 2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
    public static SingletonService getInstance() {
        return instance;
    }

    // 3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.
    private SingletonService() {
    }

    public void logic() {
        System.out.println(instance + " 싱글톤 객체 로직 호출");
    }
}
```





### @Configuration과 바이트코드 조작의 마법
- 스프링 컨테이너는 **기본적**으로 `싱글톤`으로 만들어서 관리해줍니다.
- 스프링 설정 정보에 @Configuration을 붙이면 `바이트코드를 조작하는 CGLID` 기술을 적용해서 **싱글톤을 보장**해줍니다.
- @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤은 보장하지 않는다. 그러므로 `항상 @Configuration`을 사용해야 합니다.

#### 싱글톤을 보장해주는 방식?
- @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈을 등록하고 반환하는 코드가 동적으로 만들어 집니다. 
- 덕분에 싱글톤이 보장됩니다.

### 3줄 요약 정리
> 1. 스프링 컨테이너가 싱글톤을 보장해줍니다.
> 2. @Configuration 어노테이션을 붙여 스프링이 CGLID 바이트코드 조작 라이브러리 사용해서 임의의 클래스를 생성 해서 스프링 빈으로 등록합니다.
> 3. @Configuration 어노테이션을 빼고 @Bean 어노테이션만 사용해도 스프링 빈으로 등록되지만, 싱글톤은 보장하지 않습니다.
<br>

## 컴포넌트 스캔
- 추가 해야함.

## 의존관계 자동 주입
### 다양한 의존관계 자동 주입
- 총 4가지 의존관계 주입 방법이 존재합니다.
- 생성자 의존주입, 수정자(setter) 의존주입, 필드 의존주입, 일반 메서드 의존주입

### 의존관계 주입 방법
- 생성자 주입 : 호출시점에 딱 한번만 호출되는 것을 보장
- 수정자(setter) 세터 주입 : public 메소드 이기 때문에 언제 어디서든 변경가능해서 중간에 변경이 될 위험성이 존재.
- 필드 주입 : 외부에서 변경 불가능, 테스트하기 힘들다.
  
### 생성자 의존주입
- 최근 실무에서 많이 쓰이는 주입

### 빈 등록 및 의존관계 어노테이션
1. 스프링 빈을 모두 등록한다. 설정정보 파일 @Configuration/@Bean, @Component/@Controller/@Repository 등
2. 연관관계 자동으로 주입합니다. @Autowired

### 자동 및 수동 올바른 실무 운영 기준
- 일반적인 비지니스 로직은 자동 주입
- 기술지원 로직은 수동 주입 (직접 등록)
<br>

## 빈 생명주기 콜백
### 스프링 라이프 사이클
- 스프링 빈은 간단하게 1. 객체 생성 2. 의존관계 주입을 합니다.
- 예외로 생성자 주입은 객체 생성과 동시에 의존관계 주입을 합니다.

### 스프링 빈 이벤트 라이프사이클
- 스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 → 사용 → 소멸전 콜백 → 스프링 종료
- 초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
- 소멸전 콜백 : 빈이 소멸되기 직전에 호출

### 객체의 생성과 초기화를 분리하자
- 객체 생성을 할 때는 생성자의 필수 정보(파라미터)를 받고, 메모리 할당해서 객체를 생성하는 책임을 가져야 합니다.
- 반면에 초기화는 생성된 값을 활용해서 외부 커넥션 연결 등 무거운 동작을 수행하는 책임을 가져야 합니다.

### 빈 등록 초기화 및 소멸
- 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원합니다.
1. 인터페이스(InitializingBean, DisposableBean)
  InitializingBean, DisposableBean 구현 후 afterPropertiesSet(), destroy() 메서드 오버라이딩 합니다.
  
2. 설정 정보에 초기화 메서드, 종료 메서드 지정
  @Bean(initMethod = "init", destroyMethod = "close") 
  *destoryMethod 기본값이 (inferred) (추론)으로 등록되어 close , shutdown 메서드 자동 호출합니다.
  
3. @PostConstruct, @PreDestroy 애노테이션 지원
  ```java
  @PostConstruct
  public void init() {
    System.out.println("NetworkClient.init");
    connect();
    call("초기화 연결 메시지");
  }

  @PreDestroy
  public void close() {
    System.out.println("NetworkClient.close");
    disConnect();
  }
  ```


 
 
 

### 3줄 요약 정리
> 1. **스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 → 사용 → 소멸전 콜백 → 스프링 종료** 순서로 **스프링 이벤트 라이프 사이클**이 이뤄집니다. (생성자 주입은 빈 생성과 동시에 의존관계 주입이 됩니다.)
> 2. 객체 생성과 초기화의 책임을 **분리**합니다. (객체 생성은 기본 파라미터 셋팅 값만 받으며, 객체 메모리 할당에만 책임을 부여, 초기화는 생성된 값을 통해 무거운 기능에 책임 부여)
> 3. **빈 생명주기 콜백**은 **@PostConstruct, @PreDestroy** 애노테이션이 제일 권장하는 방법이며, 코드를 고칠 수 없는 외부 lib 경우 @Bean의 initMethod, destroyMethod를 사용합니다.
<br>

## 빈 스코프


  
